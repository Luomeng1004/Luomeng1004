<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache Jackrabbit</title>
    <url>/2022/05/19/Apache-Jackrabbit/</url>
    <content><![CDATA[<h2 id="什么是Jackrabbit"><a href="#什么是Jackrabbit" class="headerlink" title="什么是Jackrabbit"></a>什么是Jackrabbit</h2><blockquote>
<p>JackRabbit就是一种面向文档的数据库，它和MongoDB，CouchDB的功能十分接近，优势在于JackRabbit遵从JCR标准，日后可以迁移到其他同样兼容JCR的性能更好的商业解决方案上。</p>
<p>Jackrabbit（内容仓库）是一个高级的信息管理系统，该系统是传统的数据仓库的扩展，它提供了诸如版本控制、全文检索、访问控制、内容分类、内容事件监视等内容服务。Jackrabbit里面有一个DataStore类，该类有两个实现，DbDataStore和FileDataStore，可以保存元数据和二进制数据。</p>
</blockquote>
<span id="more"></span>



<h2 id="什么是JCR"><a href="#什么是JCR" class="headerlink" title="什么是JCR"></a>什么是JCR</h2><p>Java Content Repository API（JSR-170）试图建立一套标准的API去访问内容仓库。</p>
<p>内容仓库可以理解为一个用来存储文本和二进制数据（图片，word文档，PDF等等）的数据存储应用程序。<br>你不用关心你真正的数据到底存储在什么地方，是关系数据库？是文件系统？还是XML？<br>通过JSR-170，你开发代码只需要引用 javax.jcr.* 这些类和接口。它适用于任何兼容JSR-170规范的内容仓库。</p>
<p><strong>JSR-170 API对不同的人员提供了不同的好处</strong></p>
<ul>
<li>对于开发者无需了解厂家的仓库特定的API，只要兼容JSR-170就可以通过JSR-170访问其仓库。</li>
<li>对于使用CMS的公司则无需花费资金用于在不同种类CMS的内容仓库之间进行转换。</li>
<li>对于CMS厂家，无需自己开发内容仓库，而专注于开发CMS应用。</li>
</ul>
<h3 id="JCR的内容仓库模型"><a href="#JCR的内容仓库模型" class="headerlink" title="JCR的内容仓库模型"></a>JCR的内容仓库模型</h3><ul>
<li>JCR的内容仓库是一个树状结构</li>
<li>树上的元素（Item）分为两类：节点（node）和属性（property）。</li>
<li>1个节点：有且只有一个父亲，有任意数目的孩子（子节点）和任意数目的属性。</li>
<li>1个属性：有且只有一个父亲（节点），它没有子节点，由一个名字和一个或多个值组成。</li>
<li>属性值的类型可以是：布尔（Boolean）、日期（Date）、双精度（Double）、长整型（Long）、字符串（String）或流（Stream）。</li>
<li>属性可以被用来存储信息，节点则被用来创建树内部的“路径”（类似文件系统的结构，节点是目录，属性是实际的文件）</li>
</ul>
<img src="http://img.boomclap.cn/uPic/202205/1653137914772zC6aqK.png" alt="image-20220521205834607" style="zoom:50%;" />

<p>​		从上面的图中不难发现，根节点下有多个子节点a、b、c，每个子节点下面又会有多个子节点或属性。例如：a节点下有两个子节点d和e，而e含有两个属性节点j和k，属性j包含了一幅图片，属性k为一个浮点数字；同样的属性g包含了一段字符串而属性h则包含了一个整型数字。</p>
<p>　　上面图中的每个节点都可以通过他们在层次结构中的绝对路径来唯一标识。例如：“&#x2F;”可以定位到根节点，而路径&#x2F;a&#x2F;d&#x2F;i则引用了值为“ture”的属性 i。同时绝对路径总是以“&#x2F;”开始的，而相对路径则是以层次中的某个节点为参考物的。例如：相对于&#x2F;a而言，我们可以通过d&#x2F;i来定位到值为“true” 的属性i。</p>
<p>从对象关系角度上看，因为节点和属性含有很多共性的同时又有各自的特点，因而他们在扩展了Item接口的同时增加了自己独特的方法。我们可以用UML图（1-3）来表示他们之间的关系：</p>
<p><img src="http://img.boomclap.cn/uPic/202205/1653137789714eLYcJV.jpg" alt="img"></p>
<p>从UML图中我们不难看出，Node和Property都是Item的子类，每个Property节点有且只有一个Node类型的父节点，而每个Node节点只能有0个（根节点）或一个Node父节点，以及多个Item子节点。</p>
<h3 id="JCR-API"><a href="#JCR-API" class="headerlink" title="JCR API"></a>JCR API</h3><p>使用JCR API时，为了更容易的完成JCR更换，同时尽可能的减少代码变动，建议使用来自javax.jcr包的接口。</p>
<p>Jcr的包结构介绍如下表：</p>
<table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Javax.jcr</td>
<td>java技术下内容管理的接口和类</td>
</tr>
<tr>
<td>Javax.jcr.lock</td>
<td>内容管理锁功能需要的接口和类</td>
</tr>
<tr>
<td>Javax.jcr.nodetype</td>
<td>对内部节点操作相关的功能</td>
</tr>
<tr>
<td>Javax.jcr.obeservation</td>
<td>事件订阅处理相关的功能</td>
</tr>
<tr>
<td>Javax.jcr.query</td>
<td>内容查询相关的功能</td>
</tr>
<tr>
<td>Javax.jcr.query.qom</td>
<td>内容查询的对象模型定义</td>
</tr>
<tr>
<td>Javax.jcr.retention</td>
<td>保持管理相关的功能</td>
</tr>
<tr>
<td>Javax.jcr.security</td>
<td>访问控制管理相关的功能</td>
</tr>
<tr>
<td>Javax.jcr.util</td>
<td>通用帮助类</td>
</tr>
<tr>
<td>Javax.jcr.version</td>
<td>版本控制相关的功能</td>
</tr>
</tbody></table>
<p>在jcr中，一个Repository对象代表了整个仓库，客户端可以通过Repository.login方法连接到仓库，连接时可以指定一个工作空间和相关凭证。Login方法返回一个Session对象，它代表客户端和仓库之间的连接，该对象同时还封装了登录用户的授权集合以及到可访问工作空间的绑定。工作空间与Session之间是一一对应的关系，我们可以把工作空间看作是当前用户授权集合下能够访问到的内容实体的视图。</p>
<p>常用的接口</p>
<ul>
<li>Node Session.getRootNode()：获取根节点，通过该节点可以访问该Session对象有权限访问的所有节点</li>
<li>Node Node.getNode(String relPath)：通过相对路径获取到某节点</li>
<li>Node Node.addNode(String node)：为Node对象添加子节点</li>
<li>Void Node.remove()：删除节点对象</li>
<li>Property Node.getProperty(String relPath)：通过相对路径获取属性对象</li>
<li>Void Node.setProperty(String name, String value)：为Node对象设置属性值</li>
<li>String Property.getString()：获取属性对象的值</li>
<li>Value Property.getValue()：获取对属性对象值的原类型封装对象</li>
<li>String Value.getString()：获取属性值封装对象的实际数据值</li>
<li>Item Session.getItem(String abspath)：通过绝对路径直接定位到某节点对象</li>
<li>Void Session.save()：持久化Session对象</li>
<li>Node Session.getNodeByUUID(String uuid)：通过全局唯一定位符直接定位到有唯一定位符的节点对象</li>
</ul>
<h2 id="为什么要用使用JCR引擎"><a href="#为什么要用使用JCR引擎" class="headerlink" title="为什么要用使用JCR引擎"></a>为什么要用使用JCR引擎</h2><blockquote>
<p>究竟该使用JCR引擎，还是直接使用关系型数据库？</p>
</blockquote>
<ul>
<li>JCR适合数据浏览（Navigation）和版本化信息查询（Versioning），而RDBMS适合复杂联合查询</li>
<li>关系型SQL很强大，但在需要查询整个树状数据时，则需要使用其它模型，另外关系型数据对于版本控制以及访问控制的支持也不好</li>
</ul>
<p>TODO</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><h4 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Repository</span></span></span><br><span class="line"><span class="meta">	  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//The Apache Software Foundation//DTD Jackrabbit 1.5//EN&quot;</span></span></span><br><span class="line"><span class="meta">	  <span class="string">&quot;http://jackrabbit.apache.org/dtd/repository-1.5.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FileSystem</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Security</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Workspaces</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Workspace</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Versioning</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">SearchIndex</span> <span class="attr">...</span>/&gt;</span>  <span class="comment">&lt;!-- optional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Cluster</span> <span class="attr">...</span>/&gt;</span>	  <span class="comment">&lt;!-- optional, available since 1.2 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DataStore</span> <span class="attr">...</span>/&gt;</span>	  <span class="comment">&lt;!-- optional, available since 1.4 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Repository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#file-system-configuration">FileSystem</a>: 存储库用来存储注册名称空间和节点类型等内容的虚拟文件系统</li>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#security-configuration">Security</a>: 认证授权配置</li>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#workspace-configuration">Workspaces</a>: 配置工作空间的管理位置和方式</li>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#workspace-configuration">Workspace</a>: 默认工作区配置模板</li>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#versioning-configuration">Versioning</a>: 存储库范围的版本存储的配置</li>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#search-configuration">SearchIndex</a>: 覆盖存储库范围的搜索索引的配置 &#x2F;jcr:system 内容树</li>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#cluster-configuration">Cluster</a>: 集群配置</li>
<li><a href="https://jackrabbit.apache.org/jcr/jackrabbit-configuration.html#data-store-configuration">DataStore</a>: 数据存储配置</li>
</ul>
<h4 id="配置中的变量"><a href="#配置中的变量" class="headerlink" title="配置中的变量"></a>配置中的变量</h4><ul>
<li><code>$&#123;rep.home&#125;</code>: Repository home directory.</li>
<li><code>$&#123;wsp.name&#125;</code>: Workspace name. Only available in workspace configuration.</li>
<li><code>$&#123;wsp.home&#125;</code>: Workspace home directory. Only available in workspace configuration.</li>
</ul>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用插件</title>
    <url>/2022/05/21/IDEA%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackrabbit的可视化</title>
    <url>/2022/05/20/Jackrabbit%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h2 id="如何可以查看存储在MySQL中的JackRabbit数据"><a href="#如何可以查看存储在MySQL中的JackRabbit数据" class="headerlink" title="如何可以查看存储在MySQL中的JackRabbit数据"></a>如何可以查看存储在MySQL中的JackRabbit数据</h2>]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Jackrabbit</tag>
      </tags>
  </entry>
  <entry>
    <title>Java成长之路</title>
    <url>/2022/05/20/Java%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="Java成长之路"><a href="#Java成长之路" class="headerlink" title="Java成长之路"></a>Java成长之路</h1><blockquote>
<p>闲时之路，忙时有书，阅读丈量世界，一章一篇总关情。</p>
</blockquote>
<span id="more"></span>



<h2 id="一、Java"><a href="#一、Java" class="headerlink" title="一、Java"></a>一、Java</h2><h3 id="1-连引用都答不上，凭什么说你是Java服务端开发"><a href="#1-连引用都答不上，凭什么说你是Java服务端开发" class="headerlink" title="1.连引用都答不上，凭什么说你是Java服务端开发"></a>1.连引用都答不上，凭什么说你是Java服务端开发</h3><p><strong>【划重点】在Java中引用包括：</strong></p>
<ul>
<li>FinalReference 强引用</li>
<li>SoftReference 软引用</li>
<li>WeakReference 弱引用</li>
<li>PhantomReference 虚引用</li>
</ul>
<p>那么为什么会提供这四种引用呢，主要原因有：</p>
<ul>
<li>方便Jvm进行垃圾回收</li>
<li>方便开发人员使用，开发人员可以灵活的决定某些对象的生命周期</li>
</ul>
<h4 id="FinalReference-强引用"><a href="#FinalReference-强引用" class="headerlink" title="FinalReference 强引用"></a>FinalReference 强引用</h4><p>类似于 Object o &#x3D; new Object() 这类的引用，创建一个对象后，该引用会被保存在JVM栈中，而且只要强引用存在，垃圾回收器就不会回收掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>



<h4 id="SoftReference-软引用"><a href="#SoftReference-软引用" class="headerlink" title="SoftReference 软引用"></a>SoftReference 软引用</h4><p>软引用关联的对象，在内存不够的情况下，会把这些软引用关联的对象列入垃圾回收范围中，然后进行回收，也就是说软引用并非是完全安全的，在内存不够的情况下是会被垃圾回收器回收掉的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        SoftReference[] softReferences = <span class="keyword">new</span> <span class="title class_">SoftReference</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            softReferences[i] = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;TestObject&gt;(<span class="keyword">new</span> <span class="title class_">TestObject</span>(<span class="string">&quot;TestObject-&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> softReferences[i].get();</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(((TestObject) o).name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] values;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestObject</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        values = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">500</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释便可以知道，我这里实例化了多个大对象，然后放入softReferences数组中，之后便遍历打印出其中的对象的命名，打印结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">TestObject-3</span><br><span class="line">TestObject-4</span><br></pre></td></tr></table></figure>

<p>可以通过结果看出，前面四个对象因为内存不够而被垃圾回收器回收了。</p>
<p><strong>日常使用</strong></p>
<p>在我司的项目中，部分是使用软引用来保存从数据库中取出的数据，具体是做了一个中间层的封装，该中间层的作用就是在get出数据的时候会去判断数据是否为null，如果是为null再次从数据库读取，读取后再放入软引用的集合中，这样的做法是可以避免内存溢出。</p>
<h4 id="WeakReference-弱引用"><a href="#WeakReference-弱引用" class="headerlink" title="WeakReference 弱引用"></a>WeakReference 弱引用</h4><p>弱引用比软引用更弱，被弱引用关联的对象只能存活到发生下一次垃圾回收之前，也就是说当发生GC时，无论当前内存是否足够，都会被回收掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;String&gt; stringWeakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;I am here!&quot;</span>));</span><br><span class="line">        System.out.println(stringWeakReference.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(stringWeakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简短，就是先构建一个弱引用对象，然后在gc前先打印出来证明它存在过，之后手动调用gc，再次打印，可以看出已经没了。运行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I am here!</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h4 id="PhantomReference-虚引用"><a href="#PhantomReference-虚引用" class="headerlink" title="PhantomReference 虚引用"></a>PhantomReference 虚引用</h4><p>虚引用和上面不同的地方在于，一个对象是否有虚引用的存在，完全不会对其生存时间构成如何影响，并且也无法通过虚引用来获取一个对象的实例，也就是说跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p>
<p>那么这样就很容易产生疑问了，虚引用的作用又是什么呢？</p>
<p>作用就是能在这个对象被收集器回收时收到一个系统通知，实现追踪垃圾收集器的回收动作，比如在对象被回收的时候，会调用该对象的finalize方法。</p>
<p>在给出相关demo前，要先介绍一个</p>
<p><strong>ReferenceQueue 引用队列</strong></p>
<p>ReferenceQueue 引用其实也可以归纳为引用中的一员，可以和上述三种引用类型组合使用【软引用、弱引用、虚引用】。</p>
<p>那么它有何作呢？</p>
<p>在创建Reference时，手动将Queue注册到Reference中，而当该Reference所引用的对象被垃圾收集器回收时，JVM会将该Reference放到该队列中，而我们便可以对该队列做些其他业务，相当于一种通知机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceQueue</span> <span class="variable">referenceQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;I am here&quot;</span>), referenceQueue);</span><br><span class="line">        System.out.println(<span class="string">&quot;phantomReference.get():&quot;</span> + phantomReference.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Reference&lt;?&gt; reference;</span><br><span class="line">        <span class="keyword">while</span> ((reference = referenceQueue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reference == phantomReference) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被回收了...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插曲：IDEA打印GC日志的方法，在vm选项中添加<code>-XX:+PrintGCDetails</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phantomReference.get():null</span><br><span class="line">被回收了...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>我们可以从结果中看到先是从引用中get出来的对象为null，证明上面说的无法通过虚引用来获取一个对象的实例，并且在回收后会被放入队列中。</p>
<h4 id="和Reference相关的概念"><a href="#和Reference相关的概念" class="headerlink" title="和Reference相关的概念"></a>和Reference相关的概念</h4><p>首先为了方便JVM进行管理，Reference是有状态的，可以分为以下四种状态</p>
<ul>
<li>active  一般来说内存一开始被分配的状态，而当被引用的对象的可达性发生变化后gc就会将引用放入pending队列并将其状态改为pending状态。</li>
<li>pending 指的是准备要被放进pending队列的对象。</li>
<li>enqueue 指的是对象的内存已经被回收了。</li>
<li>inactive 这是最终的状态，不能再变为其它状态。</li>
</ul>
<h4 id="JVM怎么知道引用在不在"><a href="#JVM怎么知道引用在不在" class="headerlink" title="JVM怎么知道引用在不在"></a>JVM怎么知道引用在不在</h4><p>关于JVM怎么知道引用在不在，这就涉及到了JVM的可达性分析算法了 JVM的可达性分析算法的简单思路就是通过一系列GC Roots作为出发点，向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链，即表明从GC Roots到这个对象不可达时，证明此对象不可用，可被回收。如下图所示</p>
<p>哪些对象可以作为GC Roots呢? 这里给出几个，如下:</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈JNI引用的对象</li>
</ul>
<p>具体的想要深入研究的可以自行百度&amp;谷歌，或者等我后面深入分析。</p>
<h4 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h4><p>该篇文章基本解答了【谈谈对Java中几种引用的理解】，如果想要更深入的研究，就要从源码入手了解了。 下次遇见这种面试题，基本上就不慌了，因为实际上只要认真看完该篇文章并且记住几个关键的地方，基本上就不会被面试官问倒了，并且该篇文章后面也解答了【JVM怎么知道引用在不在】和【哪些对象可以作为GC Roots】的问题。</p>
<h2 id="二、Golang"><a href="#二、Golang" class="headerlink" title="二、Golang"></a>二、Golang</h2><h2 id="三、网络"><a href="#三、网络" class="headerlink" title="三、网络"></a>三、网络</h2><h3 id="3-1-网络协议"><a href="#3-1-网络协议" class="headerlink" title="3.1 网络协议"></a>3.1 网络协议</h3><ul>
<li><p>请详细描述三次握手和四次挥手的过程</p>
<p>要求熟悉三次握手和四次挥手的机制，要求画出状态图。</p>
</li>
<li><p>四次挥手中TIME_WAIT状态存在的目的是什么?</p>
<p>这个问题是画出四次挥手状态图，会引申问你。不排除还会问为什么四次挥手是四次不是二次等问题。最好是把相关问题均掌握。</p>
</li>
<li><p>TCP是通过什么机制保障可靠性的?</p>
<p>从四个方面进行回答，ACK确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。</p>
</li>
</ul>
<h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><h2 id="五、数据结构与算法"><a href="#五、数据结构与算法" class="headerlink" title="五、数据结构与算法"></a>五、数据结构与算法</h2><h2 id="六、数据库"><a href="#六、数据库" class="headerlink" title="六、数据库"></a>六、数据库</h2><h2 id="七、系统设计"><a href="#七、系统设计" class="headerlink" title="七、系统设计"></a>七、系统设计</h2><h2 id="八、工具"><a href="#八、工具" class="headerlink" title="八、工具"></a>八、工具</h2><h2 id="九、资料"><a href="#九、资料" class="headerlink" title="九、资料"></a>九、资料</h2><h2 id="十、编码实践"><a href="#十、编码实践" class="headerlink" title="十、编码实践"></a>十、编码实践</h2>]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>成长之路</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka扫盲</title>
    <url>/2022/05/20/Kafka%E6%89%AB%E7%9B%B2/</url>
    <content><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="一、架构示意图"><a href="#一、架构示意图" class="headerlink" title="一、架构示意图"></a>一、架构示意图</h3><p><img src="https://cbbing-1253804295.cos.ap-shanghai.myqcloud.com/kekefund/kafka_docker01.png" alt="img"></p>
<span id="more"></span>

<pre><code>一个典型的Kafka集群中包含若干Producer（可以是web前端FET，或者是服务器日志等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干ConsumerGroup，以及一个Zookeeper集群。

Kafka通过Zookeeper管理Kafka集群配置：选举Kafka broker的leader，以及在Consumer Group发生变化时进行rebalance，因为consumer消费kafka topic的partition的offsite信息是存在Zookeeper的。

Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。
</code></pre>
<p><img src="https://cbbing-1253804295.cos.ap-shanghai.myqcloud.com/kekefund/kafka_docker02.png" alt="img"></p>
<pre><code>一个典型的Cloud Kafka集群如上所示。其中的生产者Producer可能是网页活动产生的消息、或是服务日志等信息。生产者通过push模式将消息发布到Cloud Kafka的Broker集群，消费者通过pull模式从broker中消费消息。消费者Consumer被划分为若干个Consumer Group，此外，集群通过Zookeeper管理集群配置，进行leader选举，故障容错等。
</code></pre>
<h3 id="二、kafka特点："><a href="#二、kafka特点：" class="headerlink" title="二、kafka特点："></a>二、kafka特点：</h3><ul>
<li>它是一个处理流式数据的”发布-订阅“消息系统。</li>
<li>实时高效处理流式数据：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li>
<li>将数据安全存储在分布式集群。</li>
<li>它是运行在集群上的。</li>
<li>它将流式记录存储在topics中。</li>
<li>每个record由key, value和timestamp组成。</li>
</ul>
<h3 id="三、Docker搭建"><a href="#三、Docker搭建" class="headerlink" title="三、Docker搭建"></a>三、Docker搭建</h3><p>参考：<a href="https://github.com/wurstmeister/kafka-docker?spm=a2c4e.11153940.blogcont657849.14.52db6f5c8a3J7i">https://github.com/wurstmeister/kafka-docker</a></p>
<p>docker-compose.yml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  zookeeper:</span><br><span class="line">    image: wurstmeister/zookeeper</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data:/data</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;2181:2181&quot;</span><br><span class="line">       </span><br><span class="line">  kafka:</span><br><span class="line">    image: wurstmeister/kafka</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9092:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_ADVERTISED_HOST_NAME: 10.154.38.115</span><br><span class="line">      KAFKA_MESSAGE_MAX_BYTES: 2000000</span><br><span class="line">      KAFKA_CREATE_TOPICS: &quot;Topic1:1:3,Topic2:1:1:compact&quot;</span><br><span class="line">      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181</span><br><span class="line">    volumes:</span><br><span class="line">      - ./kafka-logs:/kafka</span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock</span><br><span class="line"> </span><br><span class="line">  kafka-manager:</span><br><span class="line">    image: sheepkiller/kafka-manager</span><br><span class="line">    ports:</span><br><span class="line">      - 9020:9000</span><br><span class="line">    environment:</span><br><span class="line">      ZK_HOSTS: zookeeper:2181</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>KAFKA_ADVERTISED_HOST_NAME：Docker宿主机IP（如果你要配置多个brokers，就不能设置为 localhost 或 127.0.0.1）</li>
<li>KAFKA_MESSAGE_MAX_BYTES：kafka(message.max.bytes) 会接收单个消息size的最大限制，默认值为1000000 , ≈1M</li>
<li>KAFKA_CREATE_TOPICS：初始创建的topics，可以不设置</li>
<li>环境变量.&#x2F;kafka-logs为防止容器销毁时消息数据丢失。</li>
<li>容器kafka-manager为yahoo出可视化kafka WEB管理平台。</li>
</ul>
<p>操作命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动：</span><br><span class="line">$ docker-compose up -d</span><br><span class="line"> </span><br><span class="line"># 增加更多Broker：</span><br><span class="line">$ docker-compose scale kafka=3</span><br><span class="line"> </span><br><span class="line"># 合并：</span><br><span class="line">$ docker-compose up --scale kafka=3</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="四、Kakfa使用"><a href="#四、Kakfa使用" class="headerlink" title="四、Kakfa使用"></a>四、Kakfa使用</h3><h4 id="1-Kafka管理节点"><a href="#1-Kafka管理节点" class="headerlink" title="1.Kafka管理节点"></a>1.Kafka管理节点</h4><p><img src="https://cbbing-1253804295.cos.ap-shanghai.myqcloud.com/kekefund/kafka_docker03.png" alt="img"></p>
<h4 id="2-主题"><a href="#2-主题" class="headerlink" title="2.主题"></a>2.主题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">      KAFKA_CREATE_TOPICS: &quot;Topic1:1:3,Topic2:1:1:compact&quot;</span><br></pre></td></tr></table></figure>

<p>Topic1有1个Partition和3个replicas， Topic2有2个Partition，1个replica和cleanup.policy为compact。</p>
<blockquote>
<p>Topic 1 will have 1 partition and 3 replicas, Topic 2 will have 1 partition, 1 replica and a cleanup.policy set to compact.</p>
</blockquote>
<h4 id="3-读写验证"><a href="#3-读写验证" class="headerlink" title="3.读写验证"></a>3.读写验证</h4><p>读写验证的方法有很多，这里我们用kafka容器自带的工具来验证，首先进入到kafka容器的交互模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it kafka_kafka_1 /bin/bash</span><br></pre></td></tr></table></figure>

<p>创建一个主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-topics.sh --create --zookeeper 192.168.31.84:2181 --replication-factor 1 --partitions 1 --topic my-test</span><br></pre></td></tr></table></figure>

<p>查看刚创建的主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-topics.sh --list --zookeeper 192.168.31.84:2181</span><br></pre></td></tr></table></figure>

<p><img src="https://cbbing-1253804295.cos.ap-shanghai.myqcloud.com/kekefund/kafka_docker04.png" alt="img"></p>
<p>发送消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-producer.sh --broker-list 192.168.31.84:9092 --topic my-test</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure>

<p>读取消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server 192.168.31.84:9092 --topic my-test --from-beginning</span><br></pre></td></tr></table></figure>

<h3 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h3><ul>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>
</ul>
<p><img src="https://cbbing-1253804295.cos.ap-shanghai.myqcloud.com/kekefund/kafka_docker05.png" alt="img"></p>
<ul>
<li><p>消息系统：解耦和生产者和消费者、缓存消息等。</p>
</li>
<li><p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p>
</li>
<li><p>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p>
</li>
<li><p>流式处理：比如spark streaming和storm</p>
</li>
</ul>
<h3 id="六、Go语言示例"><a href="#六、Go语言示例" class="headerlink" title="六、Go语言示例"></a>六、Go语言示例</h3><h4 id="1-生产者："><a href="#1-生产者：" class="headerlink" title="1.生产者："></a>1.生产者：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producerTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;producer_test\n&quot;</span>)</span><br><span class="line">	config := sarama.NewConfig()</span><br><span class="line">	config.Producer.RequiredAcks = sarama.WaitForAll</span><br><span class="line">	config.Producer.Partitioner = sarama.NewRandomPartitioner</span><br><span class="line">	config.Producer.Return.Successes = <span class="literal">true</span></span><br><span class="line">	config.Producer.Return.Errors = <span class="literal">true</span></span><br><span class="line">	config.Version = sarama.V0_11_0_2</span><br><span class="line"></span><br><span class="line">	producer, err := sarama.NewAsyncProducer([]<span class="type">string</span>&#123;<span class="string">&quot;localhost:9092&quot;</span>&#125;, config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;producer_test create producer error :%s\n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> producer.AsyncClose()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// send message</span></span><br><span class="line">	msg := &amp;sarama.ProducerMessage&#123;</span><br><span class="line">		Topic: <span class="string">&quot;kafka_go_test&quot;</span>,</span><br><span class="line">		Key:   sarama.StringEncoder(<span class="string">&quot;go_test&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	value := <span class="string">&quot;this is message&quot;</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Scanln(&amp;value)</span><br><span class="line">		msg.Value = sarama.ByteEncoder(value)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;input [%s]\n&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// send to chain</span></span><br><span class="line">		producer.Input() &lt;- msg</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> suc := &lt;-producer.Successes():</span><br><span class="line">			fmt.Printf(<span class="string">&quot;offset: %d,  timestamp: %s&quot;</span>, suc.Offset, suc.Timestamp.String() + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> fail := &lt;-producer.Errors():</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, fail.Err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-消费者"><a href="#2-消费者" class="headerlink" title="2.消费者"></a>2.消费者</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumerTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;consumer_test&quot;</span>)</span><br><span class="line"></span><br><span class="line">	config := sarama.NewConfig()</span><br><span class="line">	config.Consumer.Return.Errors = <span class="literal">true</span></span><br><span class="line">	config.Version = sarama.V0_11_0_2</span><br><span class="line"></span><br><span class="line">	<span class="comment">// consumer</span></span><br><span class="line">	consumer, err := sarama.NewConsumer([]<span class="type">string</span>&#123;<span class="string">&quot;localhost:9092&quot;</span>&#125;, config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;consumer_test create consumer error %s\n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> consumer.Close()</span><br><span class="line"></span><br><span class="line">	partitionConsumer, err := consumer.ConsumePartition(<span class="string">&quot;kafka_go_test&quot;</span>, <span class="number">0</span>, sarama.OffsetOldest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;try create partition_consumer error %s\n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> partitionConsumer.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg := &lt;-partitionConsumer.Messages():</span><br><span class="line">			fmt.Printf(<span class="string">&quot;msg offset: %d, partition: %d, timestamp: %s, value: %s\n&quot;</span>,</span><br><span class="line">				msg.Offset, msg.Partition, msg.Timestamp.String(), <span class="type">string</span>(msg.Value))</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-partitionConsumer.Errors():</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err :%s\n&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-元数据"><a href="#3-元数据" class="headerlink" title="3.元数据"></a>3.元数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">metadata_test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;metadata test\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    config := sarama.NewConfig()</span><br><span class="line">    config.Version = sarama.V0_11_0_2</span><br><span class="line"></span><br><span class="line">    client, err := sarama.NewClient([]<span class="type">string</span>&#123;<span class="string">&quot;localhost:9092&quot;</span>&#125;, config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;metadata_test try create client err :%s\n&quot;</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get topic set</span></span><br><span class="line">    topics, err := client.Topics()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;try get topics err %s\n&quot;</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;topics(%d):\n&quot;</span>, <span class="built_in">len</span>(topics))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, topic := <span class="keyword">range</span> topics &#123;</span><br><span class="line">        fmt.Println(topic)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get broker set</span></span><br><span class="line">    brokers := client.Brokers()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;broker set(%d):\n&quot;</span>, <span class="built_in">len</span>(brokers))</span><br><span class="line">    <span class="keyword">for</span> _, broker := <span class="keyword">range</span> brokers &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, broker.Addr())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Object.assign详解</title>
    <url>/2022/05/23/Object-assign%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="一、Object-assign是什么？"><a href="#一、Object-assign是什么？" class="headerlink" title="一、Object.assign是什么？"></a>一、Object.assign是什么？</h3><p>首先了解下Object.assign()是什么。我们先看看ES6官方文档是怎么介绍的？</p>
<blockquote>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</blockquote>
<p>简单来说，就是Object.assign()是对象的静态方法，可以用来复制对象的可枚举属性到目标对象，利用这个特性可以实现对象属性的合并。</p>
<h3 id="二、用法："><a href="#二、用法：" class="headerlink" title="二、用法："></a>二、用法：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources)</span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong>target：目标对象，source：源对象<br><strong>返回值：</strong>target，即目标对象</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用手册</title>
    <url>/2022/05/21/hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let、const的区别</title>
    <url>/2022/05/25/var%E3%80%81let%E3%80%81const%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>TODO</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>投资的艺术</title>
    <url>/2022/05/19/%E6%8A%95%E8%B5%84%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<blockquote>
<p>著名投资家查尔斯·艾里斯在《投资艺术》里曾写道：“当闪电打下来的时候，你最好在场”。</p>
</blockquote>
]]></content>
      <tags>
        <tag>投资的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>札记</title>
    <url>/2022/05/20/%E6%9C%AD%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>读书其实没什么用，但它能让人平静。平静这种心情，在这样躁动的年代，是一种精神药物。书，摆在书架上，就像是一颗颗药丸。各有不同的功效，治各种不同的精神创伤。</p>
<p>你问我，读书有什么用？我想，就像是你吃一个桃子，桃子吃完了，桃核扔了。你以为一切都已经结束了，但第二年才发现，桃核破土而出，长出了新的桃树苗。</p>
<p>这种奇异的美妙，就像是相忘于江湖后，还有种相濡以沫的藕断丝连。</p>
</blockquote>
<span id="more"></span>



<h2 id="过往"><a href="#过往" class="headerlink" title="过往"></a>过往</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>年份</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://book.douban.com/subject/35049755/">索拉里斯星</a></td>
<td>[波] 斯坦尼斯瓦夫·莱姆</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35093361/">中台产品经理宝典：从业务建模到中台设计全攻略</a></td>
<td>刘天</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35031587/">绝叫</a></td>
<td>[日] 叶真中显</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35390390/">字母表谜案</a></td>
<td>大山诚一郎</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35494160/">挽救计划</a></td>
<td>[美] 安迪·威尔</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/1872158/">蝇王</a></td>
<td>[英] 威廉·戈尔丁</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35094680/">桶川跟踪狂杀人事件</a></td>
<td>[日] 清水洁</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35606837/">装修常用数据手册 : 空间布局和尺寸</a></td>
<td>尤呢呢</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35511433/">装修，做好三件事就够了</a></td>
<td>王奕龙 &#x2F; 后浪</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35611477/">要钱还是要生活 : 没有财务自由，也能提前退休</a></td>
<td>(美) 维姬·罗宾、(美) 乔·多明格斯</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/30143251/">老后破产 : 名为“长寿”的噩梦</a></td>
<td>日本NHK特别节目录制组</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/34996429/">消失的13级台阶</a></td>
<td>[日] 高野和明 &#x2F; 赵建勋</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35005062/">银河系边缘的小失常</a></td>
<td>[以色列] 埃特加·凯雷特</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35562179/">天堂旅行团</a></td>
<td>张嘉佳</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35275855/">小懒财富自由之路：从基金开始</a></td>
<td>小懒</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/34996662/">低智商犯罪</a></td>
<td>紫金陈</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27104999/">癌症·新知：科学终结恐慌</a></td>
<td>李治中（菠萝）</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26923390/">长夜难明 : 紫金陈“推理之王”第3部</a></td>
<td>紫金陈</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/30277179/">打开一颗心 : 一位心外科医生手术台前的生死故事</a></td>
<td>[英] 斯蒂芬·韦斯塔比</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/3608208/">牧羊少年奇幻之旅</a></td>
<td>[巴西] 保罗·柯艾略</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27120450/">真相推理师：凶宅</a></td>
<td>呼延云</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26706730/">肠子的小心思</a></td>
<td>[德]朱莉娅·恩德斯</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26723423/">动物园</a></td>
<td>[日] 乙一 &#x2F; 张筱森</td>
<td>2021</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/35179866/">够笑一年的奇葩人体冷知识</a></td>
<td>SME</td>
<td>2020</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27099114/">躺着赚钱 : 一看就懂的懒人理财盈利技巧</a></td>
<td>季凯帆、康峰</td>
<td>2020</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/10828002/">游戏改变世界 : 游戏化如何让现实变得更美好</a></td>
<td>[美] 简•麦戈尼格尔（Jane McGonigal）</td>
<td>2020</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26810905/">曾国藩：又笨又慢平天下</a></td>
<td>度阴山</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/24749465/">断舍离</a></td>
<td>山下英子</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/34998167/">绝对不在场证明</a></td>
<td>[日] 大山诚一郎</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/3875749/">第十二个天体 : 《地球编年史》第一部</a></td>
<td>[美]撒迦利亚· 西琴</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/34845297/">自我边界 : 告别“糨糊”逻辑，科学地坚持自己</a></td>
<td>[澳]乔治·戴德</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/34262174/">网内人</a></td>
<td>陈浩基</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/25825590/">随遇而安</a></td>
<td>孟非</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26811407/">殉罪者</a></td>
<td>雷米</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26934555/">法医秦明作品集 : 幸存者+清道夫+尸语者+无声的证词+第十一根手指</a></td>
<td>秦明</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/1770782/">追风筝的人</a></td>
<td>[美] 卡勒德·胡赛尼</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26612116/">真相推理师：幸存</a></td>
<td>呼延云</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/4913064/">活着</a></td>
<td>余华</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/25742211/">上帝掷骰子吗? : 量子物理史话</a></td>
<td>曹天元</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26652880/">遗落的南境1：湮灭</a></td>
<td>[美] 杰夫·范德米尔</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/1916726/">鬼吹灯之龙岭迷窟</a></td>
<td>天下霸唱</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/1938591/">鬼吹灯之昆仑神宫</a></td>
<td>天下霸唱</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/3034184/">鬼吹灯Ⅱ之四巫峡棺山</a></td>
<td>天下霸唱</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/2340300/">鬼吹灯Ⅱ之三·怒晴湘西</a></td>
<td>天下霸唱</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/2265312/">鬼吹灯Ⅱ之二·南海归墟</a></td>
<td>天下霸唱</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/2149655/">鬼吹灯Ⅱ之一·黄皮子坟</a></td>
<td>天下霸唱</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/6859776/">男人帮</a></td>
<td>唐浚</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/4725541/">大漠苍狼 : 绝地勘探</a></td>
<td>南派三叔</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27088736/">心理罪·教化场</a></td>
<td>雷米</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27088738/">心理罪·城市之光</a></td>
<td>雷米</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27088735/">心理罪·画像</a></td>
<td>雷米</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27088739/">心理罪·第七个读者</a></td>
<td>雷米</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27088737/">心理罪·暗河</a></td>
<td>雷米</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26930033/">余罪8 : 一个传奇警察和毒贩、悍匪、黑道大佬的交锋实录</a></td>
<td>常书欣</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26904479/">余罪7 : 我的刑侦笔记</a></td>
<td>常书欣</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26858009/">余罪6 : 我的刑侦笔记6</a></td>
<td>常书欣</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/1485224/">悟空传</a></td>
<td>今何在</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26953606/">人类简史 : 从动物到上帝</a></td>
<td>[以] 尤瓦尔·赫拉利</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26671008/">摸金校尉之九幽将军</a></td>
<td>天下霸唱</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/25957816/">悖论13</a></td>
<td>东野圭吾</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/25884890/">死亡通知单·暗黑者</a></td>
<td>周浩晖</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/1948901/">盗墓笔记 : 七星鲁王宫</a></td>
<td>南派三叔</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26604034/">真相推理师：嬗变</a></td>
<td>呼延云</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/27043811/">愿你迷路到我身旁</a></td>
<td>蕊希</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/6518605/">三体全集 : 地球往事三部曲</a></td>
<td>刘慈欣</td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26665723/">情人</a></td>
<td>渡边淳一</td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/25747921/">从你的全世界路过 : 让所有人心动的故事</a></td>
<td>张嘉佳</td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/26694140/">晚清最后十八年 : 从甲午战争到辛亥革命</a></td>
<td>黄治军</td>
<td>2018</td>
</tr>
<tr>
<td>余罪</td>
<td>常书欣</td>
<td>2018</td>
</tr>
<tr>
<td>美国众神</td>
<td>[英] 尼尔·盖曼 &#x2F; 戚林</td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/3879026/">死亡通知单</a></td>
<td>周浩晖</td>
<td>2017</td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/1485495/">楼下的房客</a></td>
<td>九把刀</td>
<td></td>
</tr>
<tr>
<td><a href="https://book.douban.com/subject/25924253/">嫌疑人X的献身</a></td>
<td>[日]东野圭吾</td>
<td>2016</td>
</tr>
<tr>
<td>解忧杂货店</td>
<td>[日]东野圭吾</td>
<td>2016</td>
</tr>
<tr>
<td>惊天奇案</td>
<td>何马</td>
<td>2015</td>
</tr>
<tr>
<td>藏地密码1-10</td>
<td>何马</td>
<td>2015</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>札记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出React和Redux——React的工作方式</title>
    <url>/2022/05/20/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E2%80%94%E2%80%94React%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="React的理念"><a href="#React的理念" class="headerlink" title="React的理念"></a>React的理念</h3><blockquote>
<p>打一个比方，React是一个聪明的建筑工人，而jQuery是一个比较傻的建筑工人，开发者你就是一个建筑的设计师，如果是jQuery这个建筑工人为你工作，你不得不事无巨细地告诉jQuery“如何去做”，要告诉他这面墙要拆掉重建，那面墙上要新开一个窗户，反之，如果是React这个建筑工人为你工作，你所要做的就是告诉这个工人“我想要什么样子”，只要把图纸递给React这个工人，他就会替你搞定一切，当然他不会把整个建筑拆掉重建，而是很聪明地把这次的图纸和上次的图纸做一个对比，发现不同之处，然后只去做适当的修改就完成任务了。</p>
</blockquote>
<span id="more"></span>



<p>React的理念，归结为一个公式，就像下面这样：</p>
<p>UI＝render（data）</p>
<p>让我们来看看这个公式表达的含义，用户看到的界面（UI），应该是一个函数（在这里叫render）的执行结果，只接受数据（data）作为参数。这个函数是一个纯函数，所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p>
<p>对于开发者来说，重要的是区分开哪些属于data，哪些属于render，想要更新用户界面，要做的就是更新data，用户界面自然会做出响应，所以React实践的也是“响应式编程”（Reactive Programming）的思想，这也就是React为什么叫做React的原因。</p>
<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>React利用Virtual DOM，让每次渲染都只重新渲染最少的DOM元素。</p>
<p>DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。Virutal DOM不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比就会发现差别，然后修改真正的DOM树时就只需要触及差别中的部分就行。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出React和Redux——React组件的数据</title>
    <url>/2022/05/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E2%80%94%E2%80%94React%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>“差劲的程序员操心代码，优秀的程序员操心数据结构和它们之间的关系。”</p>
<p>—Linus Torvalds，Linux创始人</p>
</blockquote>
<p>毫无疑问，如何组织数据是程序的最重要问题。</p>
<p>React组件的数据分为两种，prop和state，无论prop或者state的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用prop什么时候选择用state呢？其实原则很简单，prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。</p>
<span id="more"></span>



<h3 id="React的prop"><a href="#React的prop" class="headerlink" title="React的prop"></a>React的prop</h3><p>在React中，prop（property的简写）是从外部传递给组件的数据，一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。</p>
<p>每个React组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过prop来和组件对话的。</p>
<h4 id="给prop赋值"><a href="#给prop赋值" class="headerlink" title="给prop赋值"></a>给prop赋值</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SampleButton</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;sample&quot;</span> <span class="attr">borderWidth</span>=<span class="string">&#123;2&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> &quot;<span class="attr">red</span>&quot;&#125;&#125;</span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>React组件的prop所能支持的类型则丰富得多，除了字符串，可以是任何一种JavaScript语言支持的数据类型。</p>
<h4 id="读取prop值"><a href="#读取prop值" class="headerlink" title="读取prop值"></a>读取prop值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onClickIncrementButton</span> = <span class="variable language_">this</span>.<span class="property">onClickIncrementButton</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onClickDecrementButton</span> = <span class="variable language_">this</span>.<span class="property">onClickDecrementButton</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: props.<span class="property">initValue</span> || <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过super调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super（props），那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值。很明显，给this.props赋值是React.Component构造函数的工作之一。</p>
<h4 id="propTypes检查"><a href="#propTypes检查" class="headerlink" title="propTypes检查"></a>propTypes检查</h4><p>既然prop是组件的对外接口，那么就应该有某种方式让组件声明自己的接口规范。简单说，一个组件应该可以规范以下这些方面：</p>
<ul>
<li><p>这个组件支持哪些prop；</p>
</li>
<li><p>每个prop应该是什么样的格式。</p>
</li>
</ul>
<p>React通过propTypes来支持这些功能。</p>
<p>在ES6方法定义的组件类中，可以通过增加类的propTypes属性来定义prop规格，这不只是声明，而且是一种限制，在运行时和静态代码检查时，都可以根据propTypes判断外部世界是否正确地使用了组件的属性。</p>
<p>比如，对于Counter组件的propTypes定义代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Counter</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">caption</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  <span class="attr">initValue</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中要求caption必须是string类型，initValue必须是number类型。可以看到，两者除了类型不同之外，还有一个区别：caption带上了isRequried，这表示使用Counter组件必须要指定caption；而initValue因为没有isRequired，则表示如果没有也没关系。</p>
<p>很明显，有了propTypes的检查，可以很容易发现对prop的不正确使用方法，可尽早发现代码中的错误。</p>
<p>从上面可以看得出来propTypes检查可以防止不正确的prop使用方法，那么如果组件根本就没有定义propTypes会怎么样呢？</p>
<p>可以尝试在src&#x2F;Counter.js文件中删除掉那一段给Counter.propTypes赋值的语句，在浏览器Console里可以看到红色警告不再出现。可见，没有propTypes定义，组件依然能够正常工作，而且，即使在上面propTypes检查出错的情况下，组件依旧能工作。也就是说propTypes检查只是一个辅助开发的功能，并不会改变组件的行为。</p>
<p>propTypes虽然能够在开发阶段发现代码中的问题，但是放在产品环境中就不大合适了。</p>
<p>首先，定义类的propTypes属性，无疑是要占用一些代码空间，而且propTypes检查也是要消耗CPU计算资源的。其次，在产品环境下做propTypes检查没有什么帮助，毕竟，propTypes产生的这些错误信息只有开发者才能看得懂，放在产品环境下，在最终用户的浏览器Console中输出这些错误信息没什么意义。</p>
<p>所以，最好的方式是，开发者在代码中定义propTypes，在开发过程中避免犯错，但是在发布产品代码时，用一种自动的方式将propTypes去掉，这样最终部署到产品环境的代码就会更优。现有的babel-react-optimize就具有这个功能，可以通过npm安装，但是应该确保只在发布产品代码时使用它。</p>
<h3 id="React的state"><a href="#React的state" class="headerlink" title="React的state"></a>React的state</h3><p>驱动组件渲染过程的除了prop，还有state，state代表组件的内部状态。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就要使用state。</p>
<h4 id="初始化state"><a href="#初始化state" class="headerlink" title="初始化state"></a>初始化state</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">count</span>: props.<span class="property">initValue</span> || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件的state必须是一个JavaScript对象，不能是string或者number这样的简单数据类型，即使我们需要存储的只是一个数字类型的数据，也只能把它存作state某个字段对应的值。</p>
<h4 id="读取和更新state"><a href="#读取和更新state" class="headerlink" title="读取和更新state"></a>读取和更新state</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onClickIncrementButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，通过this.state可以读取到组件的当前state。值得注意的是，我们改变组件state必须要使用this.setState函数，而不能直接去修改this.state</p>
<h3 id="prop和state的对比"><a href="#prop和state的对比" class="headerlink" title="prop和state的对比"></a>prop和state的对比</h3><p>总结一下prop和state的区别：</p>
<ul>
<li><p>prop用于定义外部接口，state用于记录内部状态；</p>
</li>
<li><p>prop的赋值在外部世界使用组件时，state的赋值在组件内部；</p>
</li>
<li><p>组件不应该改变prop的值，而state存在的目的就是让组件来改变的。</p>
</li>
</ul>
<p>组件的state，就相当于组件的记忆，其存在意义就是被修改，每一次通过this.setState函数修改state就改变了组件的状态，然后通过渲染过程把这种变化体现出来。</p>
<p>但是，组件是绝不应该去修改传入的props值的，我们设想一下，假如父组件包含多个子组件，然后把一个JavaScript对象作为props值传给这几个子组件，而某个子组件居然改变了这个对象的内部值，那么，接下来其他子组件读取这个对象会得到什么值呢？当时读取了修改过的值，但是其他子组件是每次渲染都读取这个props的值呢？还是只读一次以后就用那个最初值呢？一切皆有可能，完全不可预料。也就是说，一个子组件去修改props中的值，可能让程序陷入一团混乱之中，这就完全违背了React设计的初衷。</p>
<p>还记得第1章中我们看到的那个公式吗？</p>
<p>UI＝render（data）</p>
<p>React组件扮演的是render函数的角色，应该是一个没有副作用的纯函数。修改props的值，是一个副作用，组件应该避免。</p>
<p>严格来说，React并没有办法阻止你去修改传入的props对象。所以，每个开发者就把这当做一个规矩，在编码中一定不要踩这儿红线，不然最后可能遇到不可预料的bug。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>让 Spring Session 不在执行 Config 命令</title>
    <url>/2022/06/13/%E8%AE%A9%20Spring%20Session%20%E4%B8%8D%E5%9C%A8%E6%89%A7%E8%A1%8C%20Config%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="让-Spring-Session-不再执行-Config-命令"><a href="#让-Spring-Session-不再执行-Config-命令" class="headerlink" title="让 Spring Session 不再执行 Config 命令"></a>让 Spring Session 不再执行 Config 命令</h2><p>在集成 Spring Session 做session共享的时候，有时候我们服务器是限制使用CONFIG命令的，这就导致在项目启动的时候会没有授权的错误，通过以下方法可以屏蔽 Spring Session 的CONFIG命令，让程序可以正常运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ConfigureRedisAction <span class="title function_">configureRedisAction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigureRedisAction.NO_OP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 代码是基于 Spring Boot 的，其他请自行翻译。</p>
]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
</search>
